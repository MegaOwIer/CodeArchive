/*题目描述:有N堆纸牌,编号分别为1,2,...,N.每堆上有若干张,但纸牌总数为N的倍数.可以在任一堆上取若于张纸牌,然后移动.
　　       移牌规则为:在编号为1堆上取的纸牌,只能移到编号为 2 的堆上;在编号为N的堆上取的纸牌,只能移到编号为N-1的堆上;
           其他堆上取的纸牌,可以移到相邻左边或右边的堆上.现在要求找出一种移动方法,用最少的移动次数使每堆上纸牌数都一样多.
           例如 N=4,4堆纸牌数分别为9,8,17,6,移动3次可达到目的:
           (9 8 17 6)->(9 8 13 10)->(9 11 10 10)->(10 10 10 10)
  输入描述:第一行N(N 堆纸牌,1 <= N <= 100)
           第二行A1 A2 … An(每堆纸牌初始数,l<= Ai <=10000)
  输出描述:输出至屏幕.格式为:所有堆均达到相等时的最少移动次数.
  样例输入:4
           9 8 17 6
  样例输出:3*/

#include<iostream>
using namespace std;

int n,a[105],ar,sum,m,cnt;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)  {cin>>a[i];  sum+=a[i];}
	ar=sum/n;
	m=n/2;
	for(int i=1;i<=m;i++)
	{
		if(a[i]==ar)  continue;
		a[i+1]+=a[i]-ar;
		cnt++;
	}
	for(int i=1;i<=m;i++)
	{
		if(a[n+1-i]==ar)  continue;
		a[n-i]+=a[n+1-i]-ar;
		cnt++;
	}
	cout<<cnt;
	return 0;
}
